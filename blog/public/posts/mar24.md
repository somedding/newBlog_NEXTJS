---
title: '2024년 3월 26일'
date: '2024-03-26'
description: '2024년 3월 공부 로그'
---
# 2024년 3월 26일
## RUST

### 트레잇 이란 무엇인가...  
자바 나 c#의 인터페이스 기능과 매우 유사하다

트레잇 > 다른 구조체의 동작을 공통화 할 수 있다.  

버튼 과 체크박스 가 있을때 서로 구별 하지 않고, 그냥 공통의 동작을 하는 사양을 강제하는 것.

> 타입에 관계 없이 공통적으로 가질 수 있는 동작을 추상화 해 어디에도 쓸수 있게 한다

### 트레잇 선언 방법
```rust
trait 트레잇명 {
    fn 메서드명1(&self, 인수 1, 인수 2 ...) -> 반환 타입;
    fn 메서드명2(&self, 인수 1, 인수 2 ...) -> 반환 타입;
    ...
}
```

트레잇은 인수, 반환값만을 작성하여 정의한다. 구조체로 구현하기 위해서는 

```rust
impl 트레잇명 for 구조체명 {
    fn 메서드명(&self, 인수 1, 인수 2, ...) -> 반환타입{
        //메서드 처리
    }
}
```

### 제네릭 복습하기
제네릭은 추상적인 타입을 지정해 다양한 데이터 타입 조작을 가능하게 하는 프로그래밍 기법

제네릭을 이용하면 함수나 메서드의 사용 방법을 통일할 수 있다는 장점 외에도 코드 중복을 줄일 수 있
다.  

`i32` 타입 값을 더하기만 하는 `add_i32` 함수와 `f32` 타입 값을 더하기만 하는 `add_f32` 함수를 만들어야
한다면 다음과 같이 만들 수 있다.  

스트는 타입 체크를 엄격하게 하므로 타입이 다르면 컴파일이 되지 않는다. 하지만 타입이 다르기 때문에 다른 함수를 추가로 만들어야 한다는 건 꽤 불편한 일이다. 게다가 이렇게 비슷한 함수가 여러 개 있다면 실수가 발생할 가능성도 높다  

이럴 때 이용하는 것이 제네릭이다.  

```rust
fn add_i32(a: i32, b: i32) -> i32 {
    a + b
}

fn add_f32(a: f32, b: f32) -> f32 {
    a + b
}

fn main() {
    println!("{}", add_i32(10, 25));
    println!("{}", add_f32(10.0, 25.0));
}
```

위의 함수를 타입을 결정하지 않는 제네릭 함수로 변환하면 다음과 같다.  

```rust
fn add <T: std::ops::Add<Output=T>> (a:T, b:T) -> T {
    a + b
}

fn main() {
    println!("{}", add(10,25));
    println!("{}", add(10.0,25.0));
    println!("{}", add::<i32>(10,25)); //타입을 명시 할 경우
    //println!("{}", add('a','a')); //char 타입은 미구현 이라 에러 발생
}
```

컴파일 하면 f32 이든 i32 이든 add 함수 하나로 계산할 수 있다는 것을 알 수 있다.

제네릭 함수 정의 하는 방법

```
fn 함수명 <T: 트레잇>(인수1： T, 인수2: T, ...) -> 반환값 {
    ...
}
```

`<T:트레잇>` 부분이 중요하다. 제네릭을 사용할때 이 부분이 임의 타입으로 변경된다.

`<T: std::ops::Add<Output=T>>`
에서 `std::ops` 는 오버로드 가능한 연산자 트레잇을 정의한 모듈 이고, `::Add` 트레잇이 덧셈 트레잇 이다.

레잇을 지정하면 그 제네릭은 ‘덧셈을 할 수 있는
타입’을 지정할 수 있다는 의미다.  

비슷한 개념으로 인수 값을 2배로 만드는 제네릭을 만들 수 있다
```rust
// 인수 값을 2배로 만드는 제네릭
fn x2 <T: std::ops::Add<Output=T> + Copy> (n: T) -> T {
    n + n
}
fn main() {
    println!("{}", x2(3));
    println!("{}", x2(3.0f64));
    println!("{}", x2::<u64>(3));
}
```

`Copy` 트레잇을 구현 함으로써 2배로 만들 수 있다. 2개 이상의 트레잇을 지정 할 때에는 '+' 를 이용한다.

제네릭 함수 에서 Where을 사용하는 방법

```rust
fn 함수명 <T>(인수1 : T, 인수2: T, ...) -> 반환값
    where T: 트레잇
    {
        ...
    }
```

위 프로그램을 where을 사용한 제네릭으로 고친 함수  

```rust
fn add <T> (a:T, b:T) -> T
    where T: std::ops::Add<Output=T>
{
    a + b
}

fn main() {
    println!("{}", add(10, 25));
    println!("{}", add(10.0, 25.0));
}
```

구조체에 제네릭을 지정하기

함수 뿐 아니라 구조체를 선언 할 때도 제네릭을 지정 할 수 있다.

구조체 정의를 할 때 붙인 속성
`#[derive(Debug)]`
가 있으므로 구조체의 각 필드 값을 println! 매크
로로 출력할 수 있다.

# 2024년 3월 31일
## HTML

```html
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>멋쟁이사자처럼:)</title>

    <meta property="og:title" content="멋쟁이 사자처럼 화이팅"> 
    <meta property="og:description" content="멋쟁이 사자 처럼과 즐거운 코딩"> 
    <meta property="og:image" content="./thumbnail.JPG"> 
</head>
<body>
    
    <!-- 표제 -->
    <h1>모두를 위한 코딩 강의</h1>
    <h2>멋쟁이 사자 처럼 스쿨</h2>

    <p>멋쟁이사자처럼<br>여러분을 환영합니다.</p>

    <p>주석 처리는 cmd + / </p>

    <ol>
        <li>
            <a href="https://techit.education/">프론트엔드 수쿨
            </a>
        </li>
        <li>백엔드 스쿨</li>
        <li>블록체인 스쿨</li>
    </ol>
</body>
</html>
```

`cmd + /` : 를 이용하면 간단하게 해당 문장을 주석 처리 할 수 있다.
### head
`meta` : 태그를 이용하여 property 값과 content 값을 설정 할 수 있다
`./` : 다음을 이용하여 폴더 내의 파일을 들고 올 수 있다.

### body
`<h1></h1>` : h1 태그 h6까지 설정 할 수 있고 숫자가 작을 수록 크기가 커진다

### 레이아웃
반드시 이용해야하는 것 을 아니지만, 보통 이렇게 구성된다  

```html
<header>
서비스를 대표하는 것
<nav>

<section>
실제적인 내용이 들어감
<footer>
저작권 정보, 연락처 정보
```

    semantic 
    의미가 잘 전달되는 웹

### 정적인 웹을 배포하기
반드시 `index.html` 로 설정 해야한다.

`[계정명].github.io` 로 배포 할 수 있다.